<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Sphere Manager with Links</title>
    <style>
        body { margin: 0; overflow: hidden; cursor: default; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }
        #properties {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
            display: none;
            width: 200px;
        }
        button {
            margin: 5px;
            padding: 8px 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #2980b9;
        }
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        button.active {
            background: #e74c3c;
        }
        .property-group {
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
        }
        .mode-indicator {
            margin-top: 10px;
            padding: 8px;
            background: rgba(231, 76, 60, 0.2);
            border-radius: 4px;
            display: none;
        }
        .type-preview {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid #ccc;
        }
        .file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div id="info">
        Middle Mouse: Rotate | Right Mouse: Zoom | Left Mouse: Select Sphere | Drag Gizmo Spheres to Move
    </div>
    
    <div id="controls">
        <h3>Sphere Controls</h3>
        <button id="addSphere">Add Sphere</button>
        <button id="deleteSphere" disabled>Delete Selected</button>
        
        <h3>Link Controls</h3>
        <button id="addLink">Add Link</button>
        <button id="deleteLink">Delete Link</button>
        
        <h3>File Operations</h3>
        <button id="saveFile">Save to File</button>
        <button id="openFile">Open File</button>
        <input type="file" id="fileInput" class="file-input" accept=".json">
        
        <div id="modeIndicator" class="mode-indicator">
            <span id="modeText"></span>
        </div>
    </div>
    
    <div id="properties">
        <h3>Sphere Properties</h3>
        <div class="property-group">
            <label for="sphereType">Sphere Type:</label>
            <select id="sphereType">
                <option value="type1">Type 1 - Red</option>
                <option value="type2">Type 2 - Green</option>
                <option value="type3">Type 3 - Blue</option>
                <option value="type4">Type 4 - Yellow</option>
                <option value="type5">Type 5 - Purple</option>
            </select>
            <div class="type-preview">
                <div id="colorPreview" class="color-box"></div>
                <span id="colorName">Red</span>
            </div>
        </div>
        <button id="applyProperties">Apply Changes</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Add coordinate axes
        const axesHelper = new THREE.AxesHelper(2);
        scene.add(axesHelper);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // OrbitControls setup with custom mouse button configuration
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        // Custom mouse button configuration:
        // LEFT: null (disabled for OrbitControls, will be used for dragging)
        // MIDDLE: ROTATE
        // RIGHT: DOLLY (zoom)
        controls.mouseButtons = {
            LEFT: null,
            MIDDLE: THREE.MOUSE.ROTATE,
            RIGHT: THREE.MOUSE.DOLLY
        };
        
        // Array to store all spheres
        const spheres = [];
        
        // Array to store all links
        const links = [];
        
        // Counter for generating unique IDs
        let nextId = 1;
        
        // Define sphere types with their colors
        const sphereTypes = {
            type1: { color: 0xff0000, name: "Red" },
            type2: { color: 0x00ff00, name: "Green" },
            type3: { color: 0x0000ff, name: "Blue" },
            type4: { color: 0xffff00, name: "Yellow" },
            type5: { color: 0x800080, name: "Purple" }
        };
        
        // Function to create a new sphere
        function createSphere(type = 'type1') {
            const radius = 1; // Fixed size
            const color = sphereTypes[type].color;
            
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshLambertMaterial({ color });
            
            const sphere = new THREE.Mesh(geometry, material);
            
            // Store the type and id in userData
            sphere.userData.type = type;
            sphere.userData.id = nextId++;
            
            // Position spheres in a grid-like pattern
            const count = spheres.length;
            const gridSize = Math.ceil(Math.sqrt(count + 1));
            const x = (count % gridSize) * 2.5 - (gridSize - 1) * 1.25;
            const z = Math.floor(count / gridSize) * 2.5 - (gridSize - 1) * 1.25;
            
            sphere.position.set(x, 0, z);
            
            scene.add(sphere);
            spheres.push(sphere);
            
            return sphere;
        }
        
        // Create initial sphere
        const initialSphere = createSphere();
        
        // Create gizmo for axis-constrained dragging
        const gizmo = new THREE.Group();
        const arrowLength = 1.5;
        const sphereRadius = 0.15;
        
        // Function to create an arrow with a sphere at the end
        function createArrow(direction, color) {
            const group = new THREE.Group();
            
            // Line
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(direction.x * arrowLength, direction.y * arrowLength, direction.z * arrowLength)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            group.add(line);
            
            // Sphere at the end of the line
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color });
            const endSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            endSphere.position.copy(direction).multiplyScalar(arrowLength);
            group.add(endSphere);
            
            // Store direction in userData for later reference
            group.userData.direction = direction.clone();
            group.userData.color = color;
            
            return group;
        }
        
        // Create arrows for each axis
        const xAxis = createArrow(new THREE.Vector3(1, 0, 0), 0xff0000); // Red
        const yAxis = createArrow(new THREE.Vector3(0, 1, 0), 0x00ff00); // Green
        const zAxis = createArrow(new THREE.Vector3(0, 0, 1), 0x0000ff); // Blue
        
        gizmo.add(xAxis);
        gizmo.add(yAxis);
        gizmo.add(zAxis);
        
        // Initially hide the gizmo
        gizmo.visible = false;
        scene.add(gizmo);
        
        // State variables for dragging
        let isDragging = false;
        let selectedObject = null;
        let activeConstraint = null; // Will store the axis direction when dragging
        let initialSpherePosition = new THREE.Vector3();
        let initialMousePosition = new THREE.Vector3();
        let dragPlane = new THREE.Plane();
        
        // State variables for link operations
        let isAddingLink = false;
        let isDeletingLink = false;
        let tempSourceSphere = null;
        
        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Function to create a link between two spheres
        function createLink(sourceSphere, destinationSphere) {
            // Create a line between the two spheres
            const points = [
                sourceSphere.position.clone(),
                destinationSphere.position.clone()
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x555555, 
                linewidth: 3 
            });
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            
            // Store the link information
            const link = {
                source: sourceSphere,
                destination: destinationSphere,
                line: line
            };
            
            links.push(link);
            
            return link;
        }
        
        // Function to update a link's position
        function updateLink(link) {
            const points = [
                link.source.position.clone(),
                link.destination.position.clone()
            ];
            link.line.geometry.setFromPoints(points);
        }
        
        // Function to delete a link
        function deleteLink(link) {
            scene.remove(link.line);
            const index = links.indexOf(link);
            if (index !== -1) {
                links.splice(index, 1);
            }
        }
        
        // Function to delete all links connected to a sphere
        function deleteLinksForSphere(sphere) {
            // Loop backwards to avoid index issues when removing items
            for (let i = links.length - 1; i >= 0; i--) {
                const link = links[i];
                if (link.source === sphere || link.destination === sphere) {
                    deleteLink(link);
                }
            }
        }
        
        // Function to clear the entire scene
        function clearScene() {
            // Remove all links
            for (let i = links.length - 1; i >= 0; i--) {
                deleteLink(links[i]);
            }
            
            // Remove all spheres
            for (let i = spheres.length - 1; i >= 0; i--) {
                scene.remove(spheres[i]);
                spheres.splice(i, 1);
            }
            
            // Reset selection
            selectedObject = null;
            gizmo.visible = false;
            document.getElementById('deleteSphere').disabled = true;
            document.getElementById('properties').style.display = 'none';
            
            // Reset ID counter
            nextId = 1;
        }
        
        // Function to save the scene to a JSON file
        function saveSceneToFile() {
            // Create data structure
            const sceneData = {
                spheres: spheres.map(sphere => ({
                    id: sphere.userData.id,
                    type: sphere.userData.type,
                    position: {
                        x: sphere.position.x,
                        y: sphere.position.y,
                        z: sphere.position.z
                    }
                })),
                links: links.map(link => ({
                    source: link.source.userData.id,
                    destination: link.destination.userData.id
                }))
            };
            
            // Convert to JSON
            const json = JSON.stringify(sceneData, null, 2);
            
            // Create blob and download link
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sphere_network.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Function to load a scene from a JSON file
        function loadSceneFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    // Parse JSON
                    const sceneData = JSON.parse(e.target.result);
                    
                    // Clear current scene
                    clearScene();
                    
                    // Create a map to store spheres by their IDs
                    const sphereMap = {};
                    
                    // Create spheres
                    if (sceneData.spheres && Array.isArray(sceneData.spheres)) {
                        sceneData.spheres.forEach(sphereData => {
                            const sphere = createSphere(sphereData.type);
                            
                            // Update position
                            sphere.position.set(
                                sphereData.position.x,
                                sphereData.position.y,
                                sphereData.position.z
                            );
                            
                            // Update ID to match saved data
                            sphere.userData.id = sphereData.id;
                            
                            // Add to map
                            sphereMap[sphereData.id] = sphere;
                            
                            // Update nextId if necessary
                            if (sphereData.id >= nextId) {
                                nextId = sphereData.id + 1;
                            }
                        });
                    }
                    
                    // Create links
                    if (sceneData.links && Array.isArray(sceneData.links)) {
                        sceneData.links.forEach(linkData => {
                            const sourceSphere = sphereMap[linkData.source];
                            const destinationSphere = sphereMap[linkData.destination];
                            
                            if (sourceSphere && destinationSphere) {
                                createLink(sourceSphere, destinationSphere);
                            }
                        });
                    }
                    
                } catch (error) {
                    console.error('Error parsing JSON:', error);
                    alert('Error loading file. Please make sure it is a valid JSON file.');
                }
            };
            
            reader.readAsText(file);
        }
        
        // Mouse event handlers
        function onMouseDown(event) {
            if (event.button !== 0) return; // Only left mouse button
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // If we're in add link mode
            if (isAddingLink) {
                // Check if we clicked on a sphere
                const sphereIntersects = raycaster.intersectObjects(spheres);
                if (sphereIntersects.length > 0) {
                    const clickedSphere = sphereIntersects[0].object;
                    
                    if (!tempSourceSphere) {
                        // First sphere click - store as source
                        tempSourceSphere = clickedSphere;
                        document.getElementById('modeText').textContent = 'Now select destination sphere';
                    } else if (tempSourceSphere !== clickedSphere) {
                        // Second sphere click - create link
                        createLink(tempSourceSphere, clickedSphere);
                        
                        // Reset state
                        tempSourceSphere = null;
                        isAddingLink = false;
                        document.getElementById('addLink').classList.remove('active');
                        document.getElementById('modeIndicator').style.display = 'none';
                    }
                }
                return;
            }
            
            // If we're in delete link mode
            if (isDeletingLink) {
                // Check if we clicked on a link
                const linkIntersects = raycaster.intersectObjects(links.map(link => link.line));
                if (linkIntersects.length > 0) {
                    const clickedLine = linkIntersects[0].object;
                    
                    // Find the corresponding link
                    const linkToDelete = links.find(link => link.line === clickedLine);
                    if (linkToDelete) {
                        deleteLink(linkToDelete);
                    }
                    
                    // Reset state
                    isDeletingLink = false;
                    document.getElementById('deleteLink').classList.remove('active');
                    document.getElementById('modeIndicator').style.display = 'none';
                }
                return;
            }
            
            // If gizmo is visible, check if we clicked on an arrow's sphere
            if (gizmo.visible) {
                const gizmoIntersects = raycaster.intersectObjects(gizmo.children, true);
                
                // Filter to only get the spheres at the end of the arrows
                const sphereIntersects = gizmoIntersects.filter(intersect => 
                    intersect.object.geometry && intersect.object.geometry.type === 'SphereGeometry'
                );
                
                if (sphereIntersects.length > 0) {
                    // Find the parent group (arrow) of the intersected sphere
                    let arrow = sphereIntersects[0].object;
                    while (arrow.parent && arrow.parent !== gizmo) {
                        arrow = arrow.parent;
                    }
                    
                    if (arrow.userData.direction) {
                        // Start dragging along this axis
                        activeConstraint = arrow.userData.direction;
                        isDragging = true;
                        controls.enabled = false;
                        
                        // Save initial positions
                        initialSpherePosition.copy(selectedObject.position);
                        
                        // Create a plane perpendicular to the camera for mouse movement calculation
                        const normal = camera.getWorldDirection(new THREE.Vector3());
                        dragPlane.set(normal, -initialSpherePosition.dot(normal));
                        
                        // Get initial mouse position on the plane
                        raycaster.ray.intersectPlane(dragPlane, initialMousePosition);
                        
                        return;
                    }
                }
            }
            
            // Check if we clicked on any sphere
            const intersects = raycaster.intersectObjects(spheres);
            if (intersects.length > 0) {
                // Select the sphere
                selectedObject = intersects[0].object;
                gizmo.visible = true;
                gizmo.position.copy(selectedObject.position);
                
                // Update UI
                document.getElementById('deleteSphere').disabled = false;
                document.getElementById('properties').style.display = 'block';
                
                // Update property controls to match selected sphere
                updatePropertyControls();
            } else {
                // Clicked on background, deselect
                if (selectedObject) {
                    selectedObject = null;
                    gizmo.visible = false;
                    
                    // Update UI
                    document.getElementById('deleteSphere').disabled = true;
                    document.getElementById('properties').style.display = 'none';
                }
            }
        }
        
        function onMouseMove(event) {
            if (!isDragging || !selectedObject) return;
            
            // Calculate mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Get current mouse position on the drag plane
            const currentMousePosition = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, currentMousePosition);
            
            // Calculate displacement vector
            const displacement = new THREE.Vector3().subVectors(currentMousePosition, initialMousePosition);
            
            // Project displacement onto the active constraint axis
            const projectedDisplacement = activeConstraint.clone().multiplyScalar(displacement.dot(activeConstraint));
            
            // Update sphere position
            selectedObject.position.copy(initialSpherePosition).add(projectedDisplacement);
            
            // Update gizmo position
            gizmo.position.copy(selectedObject.position);
            
            // Update all links connected to this sphere
            links.forEach(link => {
                if (link.source === selectedObject || link.destination === selectedObject) {
                    updateLink(link);
                }
            });
        }
        
        function onMouseUp(event) {
            if (event.button !== 0) return;
            
            if (isDragging) {
                isDragging = false;
                activeConstraint = null;
                controls.enabled = true;
            }
        }
        
        // Add event listeners
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('mouseleave', onMouseUp);
        
        // Button event handlers
        document.getElementById('addSphere').addEventListener('click', () => {
            const newSphere = createSphere();
            
            // Auto-select the new sphere
            selectedObject = newSphere;
            gizmo.visible = true;
            gizmo.position.copy(selectedObject.position);
            
            // Update UI
            document.getElementById('deleteSphere').disabled = false;
            document.getElementById('properties').style.display = 'block';
            updatePropertyControls();
        });
        
        document.getElementById('deleteSphere').addEventListener('click', () => {
            if (selectedObject) {
                // Delete all links connected to this sphere
                deleteLinksForSphere(selectedObject);
                
                // Remove from scene
                scene.remove(selectedObject);
                
                // Remove from spheres array
                const index = spheres.indexOf(selectedObject);
                if (index !== -1) {
                    spheres.splice(index, 1);
                }
                
                // Reset selection
                selectedObject = null;
                gizmo.visible = false;
                
                // Update UI
                document.getElementById('deleteSphere').disabled = true;
                document.getElementById('properties').style.display = 'none';
            }
        });
        
        document.getElementById('addLink').addEventListener('click', () => {
            // Toggle add link mode
            isAddingLink = !isAddingLink;
            
            if (isAddingLink) {
                // Cancel delete link mode if active
                isDeletingLink = false;
                document.getElementById('deleteLink').classList.remove('active');
                
                // Reset temp source sphere
                tempSourceSphere = null;
                
                // Update UI
                document.getElementById('addLink').classList.add('active');
                document.getElementById('modeIndicator').style.display = 'block';
                document.getElementById('modeText').textContent = 'Select source sphere';
                
                // Change cursor
                document.body.style.cursor = 'crosshair';
            } else {
                // Update UI
                document.getElementById('addLink').classList.remove('active');
                document.getElementById('modeIndicator').style.display = 'none';
                
                // Reset cursor
                document.body.style.cursor = 'default';
            }
        });
        
        document.getElementById('deleteLink').addEventListener('click', () => {
            // Toggle delete link mode
            isDeletingLink = !isDeletingLink;
            
            if (isDeletingLink) {
                // Cancel add link mode if active
                isAddingLink = false;
                tempSourceSphere = null;
                document.getElementById('addLink').classList.remove('active');
                
                // Update UI
                document.getElementById('deleteLink').classList.add('active');
                document.getElementById('modeIndicator').style.display = 'block';
                document.getElementById('modeText').textContent = 'Click on a link to delete it';
                
                // Change cursor
                document.body.style.cursor = 'pointer';
            } else {
                // Update UI
                document.getElementById('deleteLink').classList.remove('active');
                document.getElementById('modeIndicator').style.display = 'none';
                
                // Reset cursor
                document.body.style.cursor = 'default';
            }
        });
        
        // Save file button
        document.getElementById('saveFile').addEventListener('click', () => {
            saveSceneToFile();
        });
        
        // Open file button
        document.getElementById('openFile').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        
        // File input change event
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadSceneFromFile(file);
            }
            // Reset the file input to allow opening the same file again
            e.target.value = '';
        });
        
        // Update color preview when sphere type changes
        document.getElementById('sphereType').addEventListener('change', (e) => {
            const selectedType = e.target.value;
            const typeInfo = sphereTypes[selectedType];
            
            // Update color preview
            const colorPreview = document.getElementById('colorPreview');
            colorPreview.style.backgroundColor = `#${typeInfo.color.toString(16).padStart(6, '0')}`;
            
            // Update color name
            document.getElementById('colorName').textContent = typeInfo.name;
        });
        
        document.getElementById('applyProperties').addEventListener('click', () => {
            if (!selectedObject) return;
            
            // Get selected type
            const selectedType = document.getElementById('sphereType').value;
            const typeInfo = sphereTypes[selectedType];
            
            // Update sphere material with new color
            selectedObject.material.color.set(typeInfo.color);
            
            // Update sphere type in userData
            selectedObject.userData.type = selectedType;
        });
        
        // Update property controls to match selected sphere
        function updatePropertyControls() {
            if (!selectedObject) return;
            
            // Get current type from userData
            const currentType = selectedObject.userData.type || 'type1';
            
            // Update dropdown
            document.getElementById('sphereType').value = currentType;
            
            // Update color preview
            const typeInfo = sphereTypes[currentType];
            const colorPreview = document.getElementById('colorPreview');
            colorPreview.style.backgroundColor = `#${typeInfo.color.toString(16).padStart(6, '0')}`;
            
            // Update color name
            document.getElementById('colorName').textContent = typeInfo.name;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Only rotate spheres when not being dragged
            spheres.forEach(sphere => {
                if (sphere !== selectedObject || !isDragging) {
                    sphere.rotation.y += 0.005;
                }
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>